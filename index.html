<!doctype html>
<html>

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/night.css" id="theme">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	<style media="print">
		*{
			color:rgba(0, 0, 0, 0.9) !important
		}

	</style>

</head>

<body>
	<div class="reveal">
		<div class="slides">
			<section data-timing="1">
				<img src="https://www.spec-india.com/wp-content/uploads/2019/12/Micro_Frontend-2-768x422.png"
					alt="logo ponencia">
			</section>
			<section>
				<section data-markdown>
					<script type="text/template">
						## MICROSERVICIOS

						La arquitectura de microservicios [...] consiste en construir una aplicación como un conjunto de **pequeños servicios**, los cuales se ejecutan en su propio proceso y se comunican con mecanismos ligeros (normalmente una API de recursos HTTP) [Wikipedia](https://es.wikipedia.org/wiki/Arquitectura_de_microservicios)
						
					</script>					
				</section>
				<section>
					<img src="https://miro.medium.com/max/3498/1*xu1Ge_Cew0DHdSU6ETcpLQ.png" alt="microsercio">
				</section>
				<section>
					<h3>Ventajas</h3>
					<ul>
						<li class="fragment fade-up"><b>Modularidad</b> -> se pueden desarrollar y desplegar de forma independiente.</li>
						<li class="fragment fade-up"><b>Escalabilidad </b> -> se puede escalar cada parte según sea necesario.</li>
						<li class="fragment fade-up"><b>Versatilidad</b> -> usar diferentes tecnologías y lenguajes.</li>
						<li class="fragment fade-up"><b>Rapidez de actuación</b> -> desarrollo menos costoso.</li>
						<li class="fragment fade-up"><b>Mantenibilidad</b> -> mejoras independientes.</li>
						<li class="fragment fade-up"><b>Agilidad</b> -> Reusar código de terceros.</li>
					</ul>
				</section>
			</section>
			<section>
				<h3>Actualidad</h3>
				<img src="https://ingenieriadesoftware.es/wp-content/uploads/2020/08/microfrontends-1280x640.png" />
			</section>
			<section>
				<h3>Los problemas</h3>
				<ul>
					<li class="fragment fade-up"><b>Mantenimiento</b> -> código desarrollo por muchos de distintos niveles y a lo largo de tiempo, se vuelve complejo.</li>
					<li class="fragment fade-up"><b>Conflictos de código</b> -> desarrollos en paralelo sobre un mismo repositorio. Los merges de la muerte</li>
					<li class="fragment fade-up"><b>Una sola técnología</b> -> el monolito implica amplicar una única tecnología en todo la aplicación.</li>
					<li class="fragment fade-up"><b>Entrega continua</b> -> las funcionaldiades deben estar completas.</li>					
				</ul>
				<aside class="notes">
					<h3>funcionalidad completa</h3>
					<p>El cliente no quiere salir con algo, por ejemplo un PTV nuevo, parcheos.</p>					
				</aside>
			</section>
			<section>
				<section>
					<h3>MICROFRONTEND</h3>

					<p>Surge en el 2016 por primera vez</p>

					<p> La idea detrás de Micro Frontends es pensar en un sitio web o aplicación web como una
						composición de
						características que son propiedad de equipos independientes. </p>

					<p>Cada equipo tiene un área de negocio definida o misión de la que se preocupa y se especializa. Un
						equipo es cross functional y desarrolla sus características end-to-end, desde la base de datos
						hasta
						la interfaz de usuario.</p>


				</section>
				<section>
					<h3>Frontends monolíticos</h3>
					<img src="https://micro-frontends-es.org/ressources/diagrams/organisational/monolith-frontback-microservices.png"
						alt="mono-1">
				</section>

				<section>
					<h3>Organización vertical Microfrontend</h3>
					<img src="https://micro-frontends-es.org/ressources/diagrams/organisational/verticals-headline.png"
						alt="mono-2">
				</section>

			</section>

			<section>
				<h3>¿Cuándo es recomendable usar esta metodología?</h3>
				<ul>
					<li>Grandes aplicaciones</li>
					<li>Múltiples equipos</li>
					<li>Tiempos de entraga distintos</li>
				</ul>
			</section>

			<section>
				<h3>Beneficios</h3>
				<ul>
					<li>A ser más pequeña la aplicación carga más rápido</li>
					<li>Merge más simples</li>
					<li>Reducción de conflictos entre Merge de otros equipos</li>
					<li>Múltiples framework, según el problema. Transparente al cliente</li>
				</ul>
			</section>

			<section>
				<h3>¿Cuándo no usar esta metodología?</h3>
				<ul>
					<li>Pequeños equipos</li>
					<li>Cuándo los mircofrontend compliquen el desarrollo</li>
					<li>Cuando no estemos usando métodos automáticos de despliegue</li>
					<li>Cuando el equipo sea demasiado junior.</li>
				</ul>
			</section>

			<section>
				<h3>Cómo trocear la aplicación</h3>
				<ul>
					<li><b>Por página</b> Seguro Si tiene un buen enrutamiento, puede ejecutar microaplicaciones específicas separadas para cada página.</li>
					<li><b>Por funcionalidad</b> Aisalar funcionalidades en una página  </li>					
				</ul>
				<aside class="notes">
					<h3>Por Página</h3>
					<p>Seguro: Es la forma más segura para navegadores antiguos.</p>
					<p>lo que también es bueno para los desarrolladores de su equipo, porque siempre trabajarán en esa página asignada</p>					
				</aside>
			</section>

			<section>
				<section data-background-iframe="https://micro-frontends-es.org/0-model-store/" data-background-interactive data-background="#FFF">					
				</section>
				<section>
					<h4>Responsabilidad de los equipos</h4>
					<img src="https://micro-frontends-es.org/ressources/screen/three-teams.png" width="768"  />
				</section>
			</section>

			<section>
				<section>
					<h3>Técnicas montar esta arquitectura</h3>
				</section>
				<section>
					<h3>Build-time integration</h3>
					Paquetizar los módulos y crear un paquete que los importe y gestione todos. Por ejemplo una PWA					

					<pre data-id="code-animation"><code class="hljs"><script type="text/template">
{
	"name": "@feed-me/container",
	"version": "1.0.0",
	"description": "A food delivery web app",
	"dependencies": {
		"@feed-me/browse-restaurants": "^1.2.3",
		"@feed-me/order-food": "^4.5.6",
		"@feed-me/user-profile": "^7.8.9"
	}
}
				</script></code></pre>
					
				</section>
				<section>
					<h3>¿Quién lo usa?</h3>
					<img src="https://www.goalsystems.com/wp-content/uploads/2019/07/GS_logo.png" height="200">
					<img src="https://play-lh.googleusercontent.com/gpKh0PR6Ucl2PY5HnSVRuoFy4NZhzJ_6_b1_paVYVE7kyNnzET3fSX57vWufWYYkKnHZ" height="200">
				</section>
			
			<section>
				<h3>Run-time integration via iframes</h3>
				Recuperar el uso de los iframe

				<pre data-id="code-animation"><code class="hljs"><script type="text/template">
<iframe id="micro-frontend-container"></iframe>

<script type="text/javascript">
	const microFrontendsByRoute = {
	'/': 'https://browse.example.com/index.html',
	'/order-food': 'https://order.example.com/index.html',
	'/user-profile': 'https://profile.example.com/index.html',
	};

	const iframe = document.getElementById('micro-frontend-container');
	iframe.src = microFrontendsByRoute[window.location.pathname];
/script>
			</script></code></pre>
				
			</section>
			<section>
				<h3>¿Quién lo usa?</h3>
				<img src="http://spootmedia.com/wp-content/uploads/2020/07/spotify-logo-1920x1080_fouoik.jpg" height="200">				
			</section>
			<section>
				<h3>Web components</h3>
				<p>Similar a iframe, pero en vez de frames cada front se transforma en un web component</p>
				<img src="https://www.digital55.com/wp-content/uploads/2019/11/introduccion-a-web-components.jpg?x72330" height="200">		
			</section>
			<section>
				<h3>¿Quién lo usa?</h3>
				<img src="https://chefmode.mx/wp-content/uploads/2020/12/open-table.jpg" height="200">		
				<p>Reservas de mesa en restaurantes</p>
			</section>
			<section>
				<h3>Meta framework</h3>
			</section>			
				<section>
					<h3>BIT</h3>

					Muy común y con muchas recomendaciones, es de pago.

					<img src="https://miro.medium.com/max/6208/1*V7pkn8njybmOwAC46h-oUA.png" alt="bit">

				</section>
				<section>
					<h3>Webpack 5 and Module Federation</h3>

					Mucha gente conoce ya webpack, es complejo de configurar. Crea un bundle de módulos

				</section>
				<section>
					<h3>Single SPA</h3>
					Se crea un orquestador que controla el resto de Frontends y mediente un builder se generan los modulos y se unen
				</section>
				<section>
					<h3>Otros</h3>
					<ul>
						<li><b>Systemjs</b></li>
						<li><b>Piral </b></li>
						<li><b>Open Components</b></li>
						<li><b>Qiankun</b> -> basado en single-spa.</li>
						<li><b>Luigi</b></li>
						<li><b>FrintJS</b></li>
					</ul>
				</section>
			
		</section>				
			

			<section>
				<h3>¿Cúal usaremos en la prueba?</h3>
			</section>

			<section data-background="#21371b">
				<h3>Podium</h3>
				<img src="https://podium-lib.io/img/podium.png" alt="podium">
			</section>

			<section>
				<section>
					<h3>Módulos que nos ofrece Podium</h3>
				</section>
				<section>
					<h2>@podium/layout</h2>
					<p>Base de todos los microfront. Él tiene la responsabilidad de montar todos</p>
					<p>Necesita de un servidor para poder funcionar (Express, Hapi, Fastify) </p>
				</section>
				<section>
					<h2>@podium/podlet</h2>
					<p>Es el encargado de exponer la configuración (js y css) del microfront.</p>
				</section>
				<section data-auto-animate>
					<h2>@podium/browser</h2>
					<p>Actualmente sólo sirve como gestor de mensajes entre Frontends</p>
					<pre data-id="code-animation"><code class="hljs"><script type="text/template">
import { MessageBus } from '@podium/browser';
const messageBus = new MessageBus();

messageBus.publish(channel, topic, payload);

messageBus.subscribe(channel, topic, event => {});
				</script></code></pre>
				</section>
			</section>
			<section data-auto-animate>
				<section>
					<h2 data-id="code-title">Cambios en App Vue</h2>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|8"><script type="text/template">
						import Vue from 'vue'
						import App from './App.vue'

						Vue.config.productionTip = false

						new Vue({
						render: h => h(App),
						}).$mount('#app')
					</script></code></pre>
				</section>
				<section>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|8"><script type="text/template">
						import Vue from 'vue'
						import App from './App.vue'

						Vue.config.productionTip = false

						new Vue({
						render: h => h(App),
						}).$mount('#nombre-microfront')
					</script></code></pre>
				</section>
				<section>
					<h3>Cambio en public/index.html</h3>
					<pre><code class="html"><noscript>
<strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
</noscript>
<div id="app"></div>
<!-- built files will be auto injected --></code></pre>

					<pre><code class="html"><noscript>
<strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
</noscript>
<div id="nombre-microfront"></div>
<!-- built files will be auto injected --></code></pre>

				</section>
				<section>
					<h3>Script de arranque</h3>
					<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|8"><script type="text/template">
					"start": "set NODE_ENV=production && node podlet.js ", 
					"start:dev": "set NODE_ENV=development && node podlet.js "
					</script></code></pre>
				</section>
			</section>
			<section>
				<h3>Configuración de podlet</h3>
				<pre data-id="code-animation"><code class="hljs" data-trim data-line-numbers="|1-7|9-10" ><script type="text/template">
				const podlet = new Podlet({
					name: "vueLogin", // required
					version: "0.1.0", // required
					pathname: "/", // required
					manifest: "/manifest.json", // optional, 
					development: true, // optional, defaults to false
				  });		
				
				app.use("/css", express.static("dist/css/"));
				app.use("/js", express.static("dist/js/"));
				</script></code></pre>

				<aside class="notes">
					<p>Recordar decir que hay que lanzar un build para que se genere los archivos en dist </p>
					<p>El valor por defecto de manifest es manifest.json</p>
				</aside>
			</section>
			<section data-background-iframe="https://mf-base.herokuapp.com/" data-background-interactive>
				<div style="position: absolute; width: 40%; right: 0; box-shadow: 0 1px 4px rgba(0,0,0,0.5), 0 5px 25px rgba(0,0,0,0.2); background-color: rgba(0, 0, 0, 0.9); color: #fff; padding: 20px; font-size: 20px; text-align: left;">
					<h2>Site</h2>
					<p>La página la conforman 5 microfront.</p>
					<ul>
						<li>Cabecera</li>
						<li>Emisor</li>
						<li>Receptor</li>
						<li>Pie</li>
						<li>Login</li>
					</ul>
				</div>
			</section>
		</div>
	</div>

	<script src="dist/reveal.js"></script>
	<script src="plugin/notes/notes.js"></script>
	<script src="plugin/markdown/markdown.js"></script>
	<script src="plugin/highlight/highlight.js"></script>
	<script>
		// More info about initialization & config:
		// - https://revealjs.com/initialization/
		// - https://revealjs.com/config/
		Reveal.initialize({
			hash: true,

			// Learn about plugins: https://revealjs.com/plugins/
			plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
		});
	</script>
</body>

</html>